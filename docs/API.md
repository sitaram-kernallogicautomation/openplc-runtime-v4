# REST API Reference

## Overview

The OpenPLC Runtime v4 provides a REST API over HTTPS for controlling and monitoring the PLC runtime. All endpoints are accessible at `https://<host>:8443/api`.

## Base URL

```
https://localhost:8443/api
```

## Authentication

Currently, the REST API uses basic authentication for most endpoints. The WebSocket debug interface requires JWT authentication (see [Debug Protocol](DEBUG_PROTOCOL.md)).

## Common Response Format

All API responses are JSON objects. Successful responses typically include a `status` field, while errors include descriptive error messages.

## Endpoints

### Start PLC

Start the PLC program execution.

**Request:**
```http
GET /api?argument=start-plc
```

**Response:**
```json
{
  "status": "PLC started successfully"
}
```

**Possible Status Values:**
- `"PLC started successfully"` - PLC transitioned to RUNNING state
- `"PLC is already running"` - PLC was already in RUNNING state
- `"No PLC program loaded"` - No compiled program available
- `"No response from runtime"` - Runtime process not responding

---

### Stop PLC

Stop the PLC program execution.

**Request:**
```http
GET /api?argument=stop-plc
```

**Response:**
```json
{
  "status": "PLC stopped successfully"
}
```

**Possible Status Values:**
- `"PLC stopped successfully"` - PLC transitioned to STOPPED state
- `"PLC is already stopped"` - PLC was already in STOPPED state
- `"No response from runtime"` - Runtime process not responding

---

### Get PLC Status

Query the current PLC state.

**Request:**
```http
GET /api?argument=status
```

**Response:**
```json
{
  "status": "RUNNING"
}
```

**Possible Status Values:**
- `"EMPTY"` - No PLC program loaded
- `"INIT"` - Program loaded, initializing
- `"RUNNING"` - Actively executing scan cycles
- `"STOPPED"` - Program loaded but not executing
- `"ERROR"` - Recoverable error state
- `"No response from runtime"` - Runtime process not responding

---

### Ping Runtime

Check if the runtime process is responsive.

**Request:**
```http
GET /api?argument=ping
```

**Response:**
```json
{
  "status": "pong"
}
```

**Possible Status Values:**
- `"pong"` - Runtime is responsive
- `null` - Runtime not responding

---

### Upload PLC Program

Upload a ZIP file containing the PLC program generated by OpenPLC Editor v4.

**Request:**
```http
POST /api?argument=upload-file
Content-Type: multipart/form-data

file: <ZIP file>
```

**Success Response:**
```json
{
  "UploadFileFail": "",
  "CompilationStatus": "COMPILING"
}
```

**Error Response:**
```json
{
  "UploadFileFail": "Error message",
  "CompilationStatus": "FAILED"
}
```

**Compilation Status Values:**
- `"IDLE"` - No build in progress
- `"UNZIPPING"` - Extracting ZIP file
- `"COMPILING"` - Running compilation scripts
- `"SUCCESS"` - Build completed successfully
- `"FAILED"` - Build failed

**Error Conditions:**
- No file in request
- File too large (>10 MB per file, >50 MB total)
- ZIP validation failed (path traversal, compression ratio, disallowed extensions)
- Another compilation in progress
- File system error

**Notes:**
- Compilation runs asynchronously in a background thread
- Use the compilation-status endpoint to monitor progress
- The PLC is automatically stopped during compilation
- If successful, the new program is loaded and the PLC is restarted

---

### Get Compilation Status

Query the status of the most recent compilation.

**Request:**
```http
GET /api?argument=compilation-status
```

**Response:**
```json
{
  "status": "SUCCESS",
  "logs": [
    "[INFO] Starting compilation",
    "[INFO] Compiling Config0.c...",
    "[INFO] Compiling Res0.c...",
    "[INFO] Compiling debug.c...",
    "[INFO] Compiling glueVars.c...",
    "[INFO] Compiling c_blocks_code.cpp...",
    "[INFO] Compiling shared library...",
    "[INFO] Build finished successfully"
  ],
  "exit_code": 0
}
```

**Response Fields:**
- `status` - Current build status (IDLE, UNZIPPING, COMPILING, SUCCESS, FAILED)
- `logs` - Array of log messages from the build process
- `exit_code` - Exit code of the compilation script (0 = success, non-zero = error)

**Notes:**
- Logs are streamed in real-time during compilation
- Error messages are prefixed with `[ERROR]`
- Exit code is `null` until compilation completes

---

### Get Runtime Logs

Retrieve logs from the PLC runtime process.

**Request:**
```http
GET /api?argument=runtime-logs
GET /api?argument=runtime-logs&id=<min_id>
GET /api?argument=runtime-logs&level=<log_level>
```

**Query Parameters:**
- `id` (optional) - Minimum log ID to retrieve (for pagination)
- `level` (optional) - Filter by log level (DEBUG, INFO, WARNING, ERROR)

**Response:**
```json
{
  "runtime-logs": [
    {
      "id": 1,
      "timestamp": "2024-01-01T12:00:00.000Z",
      "level": "INFO",
      "message": "PLC started successfully"
    },
    {
      "id": 2,
      "timestamp": "2024-01-01T12:00:05.000Z",
      "level": "DEBUG",
      "message": "Scan Count: 100"
    }
  ]
}
```

**Log Levels:**
- `DEBUG` - Detailed diagnostic information
- `INFO` - General informational messages
- `WARNING` - Warning messages
- `ERROR` - Error messages

---

## Error Handling

### HTTP Status Codes

- `200 OK` - Request successful
- `400 Bad Request` - Invalid request parameters
- `401 Unauthorized` - Authentication required
- `500 Internal Server Error` - Server error

### Error Response Format

```json
{
  "error": "Error message description"
}
```

## Usage Examples

### cURL Examples

**Start PLC:**
```bash
curl -k https://localhost:8443/api?argument=start-plc
```

**Stop PLC:**
```bash
curl -k https://localhost:8443/api?argument=stop-plc
```

**Get Status:**
```bash
curl -k https://localhost:8443/api?argument=status
```

**Upload Program:**
```bash
curl -k -X POST \
  -F "file=@program.zip" \
  https://localhost:8443/api?argument=upload-file
```

**Get Compilation Status:**
```bash
curl -k https://localhost:8443/api?argument=compilation-status
```

**Get Runtime Logs:**
```bash
curl -k https://localhost:8443/api?argument=runtime-logs
```

**Note:** The `-k` flag bypasses certificate verification for self-signed certificates.

### Python Example

```python
import requests
import urllib3

# Disable SSL warnings for self-signed certificates
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

base_url = "https://localhost:8443/api"

# Get PLC status
response = requests.get(f"{base_url}?argument=status", verify=False)
print(response.json())

# Start PLC
response = requests.get(f"{base_url}?argument=start-plc", verify=False)
print(response.json())

# Upload program
with open("program.zip", "rb") as f:
    files = {"file": f}
    response = requests.post(
        f"{base_url}?argument=upload-file",
        files=files,
        verify=False
    )
    print(response.json())

# Monitor compilation
import time
while True:
    response = requests.get(
        f"{base_url}?argument=compilation-status",
        verify=False
    )
    status = response.json()
    print(f"Status: {status['status']}")

    if status["status"] in ["SUCCESS", "FAILED"]:
        print("Logs:")
        for log in status["logs"]:
            print(f"  {log}")
        break

    time.sleep(1)
```

### JavaScript Example

```javascript
const baseUrl = "https://localhost:8443/api";

// Get PLC status
fetch(`${baseUrl}?argument=status`)
  .then(response => response.json())
  .then(data => console.log(data));

// Start PLC
fetch(`${baseUrl}?argument=start-plc`)
  .then(response => response.json())
  .then(data => console.log(data));

// Upload program
const formData = new FormData();
formData.append("file", fileInput.files[0]);

fetch(`${baseUrl}?argument=upload-file`, {
  method: "POST",
  body: formData
})
  .then(response => response.json())
  .then(data => console.log(data));

// Monitor compilation
async function monitorCompilation() {
  while (true) {
    const response = await fetch(`${baseUrl}?argument=compilation-status`);
    const status = await response.json();
    console.log(`Status: ${status.status}`);

    if (status.status === "SUCCESS" || status.status === "FAILED") {
      console.log("Logs:", status.logs);
      break;
    }

    await new Promise(resolve => setTimeout(resolve, 1000));
  }
}
```

## Rate Limiting

Currently, there are no rate limits enforced. However, be mindful of:
- Only one compilation can run at a time
- Frequent start/stop commands may cause state transition issues
- Log queries can be resource-intensive with large log volumes

## Security Considerations

1. **HTTPS Only**: All communication must use HTTPS
2. **Self-Signed Certificates**: Default installation uses self-signed certificates
3. **File Upload Validation**: ZIP files undergo security checks before extraction
4. **Size Limits**: Files are limited to prevent resource exhaustion
5. **Path Validation**: All file paths are validated to prevent traversal attacks

## WebSocket Debug Interface

For real-time debugging and variable inspection, use the WebSocket interface. See [Debug Protocol](DEBUG_PROTOCOL.md) for details.

## Related Documentation

- [Architecture](ARCHITECTURE.md) - System overview
- [Debug Protocol](DEBUG_PROTOCOL.md) - WebSocket debug interface
- [Compilation Flow](COMPILATION_FLOW.md) - Build process details
- [Security](SECURITY.md) - Security features
- [Troubleshooting](TROUBLESHOOTING.md) - Common issues
